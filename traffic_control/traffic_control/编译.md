# 1.封装C++的接口

## 1.1 调用C++类情况

通过加入包装文件.h和.cpp封装C++的类，在这些文件中编写C的代码，实现对c++类的调用

```c++
//c_event_detect.h
#ifndef C_EVENT_DETECT_H
#define C_EVENT_DETECT_H

#ifdef _cplusplus
extern "C" {
#endif
    void c_call_test();          //以c语言风格，约定包装的函数
#ifdef _cplusplus
};
#endif
#endif // !C_EVENT_DETECT_H
```

```c++
//c_event_detect.cpp
#include "event_detect_in_class.h" //普通的C++头文件

#ifndef _cplusplus
#define _cplusplus
#include c_event_detect.h         //以c语言风格，约定包装的头文件
#endif

void c_call_test() {              //包装函数的实现，里面调用C++类
	Event_detect mevent;
	while (true) {
		detector_target_info_t* mdetector_target = receive_data();
		mevent.handle_data(*mdetector_target);
	}
}
```

```c++
//test_main.c                        //c语言的主函数
#include <stdio.h>
#include "c_event_detect.h"

int main(int argc,char** argv) {
	c_call_test();                  //c程序中调用包装函数

}
```

## 1.2 调用c++成员函数情况

```c++
// c_event_detect.h        
struct C_Event_detect;                            //定义一个结构体，用于实例化C++类

#ifdef _cplusplus                                //_cplusplus约定
extern "C" {  
#endif  
    
struct C_Event_detect *GetInstance(void);        //包装C++类的构造函数
void ReleaseInstance(struct C_Event_detect **ppInstance);   //包装C++类的析构函数
void cacualtion_Value(struct C_Event_detect *mevent_detect);   //包装C++类的成员函数

#ifdef __cplusplus  
};  
#endif  
```

```c++
//c_event_detect.cpp
#include "c_event_detect.h"  
#include "event_detect_in_class.h"  
  
#ifdef __cplusplus  
extern "C" {  
#endif  
struct C_Event_detect  
{  
    Event_detect mevent;                        //实例化类对象  
};  
struct C_Event_detect *GetInstance(void)  
{  
    return new struct C_Event_detect;  
}  
void ReleaseInstance(struct C_Event_detect **ppInstance)  
{  
    delete *ppInstance;  
    *ppInstance = 0;    
}  
void cacualtion_Value(struct C_Event_detect *mevent_detect){
    mevent_detect.mevent.cacualtion_Value();
}
#ifdef __cplusplus  
};  
#endif 
```

```c++
//test_main.c                               //c语言的主函数
#include "c_event_detect.h"  

int main(void)  {  
   struct C_Event_detect * mevent;  
   mevent= GetInstance();  
   cacualtion_Value(mevent);  

   ReleaseInstance(&mevent);  
   return 0;  
}  
```



# 2.windows编译event_detect

   gcc编译程序时，可能会用到**“-I”（大写i），“-L”（大写l），“-l”（小写l）**等参数

-I(**大写I**)作为第一个寻找**头文件的目录**；

-L作为第一个寻找**库文件**的目录；

-l(**小写l**)表示在上面-L路径中寻找动态库文件

```c++
 g++ event_detect_in_class.cpp -shared -o event_detect.dll -I./ -fPIC                
 g++ c_event_detect.cpp -shared -o cevent.dll -I./ -L./ -levent_detect -fPIC                                  gcc test_main.c -o main -I./ -L./ -lcevent 
```



## 2.1 事项1

注意：使用GCC编译动态链接库的项目时，在其他目录下执行很可以出现找不到动态链接库的问题。因为**编译时指定的 -L的目录，只是在程序链接成可执行文件时使用的**。**程序执行时动态链接库加载不到动态链接库。**

解决方法是使用**-wl,-rpath=<link_path>参数**，<link_path>就是链接库的路径，

例如：gcc test_main.c -o main -I./ -L./ -lcevent  -rpath = ./

​            如果不行的话，可以试着在-rpath后面加入'$ORIGIN'（加上单引号），即

​           gcc test_main.c -o main -I./ -L./ -lcevent  -rpath = '$ORIGIN'./

##  2.2 事项2

fPIC的全称是 Position Independent Code， 用于生成位置无关代码。习惯性加上。

加上fPIC选项生成的动态库，“这样的代码本身就能被放到线性地址空间的任意位置，无需修改就能正确执行。通常的方法是获取指令指针的值，加上一个偏移得到全局变量/函数的地址。”

 

在内存引用上，加不加fPIC的异同：

加了fPIC实现真正意义上的多个进程共享so文件。

多个进程引用同一个 PIC 动态库时，可以共用内存。这一个库在不同进程中的虚拟地址不同，但操作系统显然会把它们映射到同一块物理内存上。

对于不加-fPIC的

不加fPIC，则加载so文件时，需要对代码段引用的数据对象需要重定位，重定位会修改代码段的内容,这就造成每个使用这个.so文件代码段的进程在内核里都会生成这个.so文件代码段的copy.每个copy都不一样,取决于这个.so文件代码段和数据段内存映射的位置。

可见，这种方式更消耗内存。

但是不加fPIC编译的 so文件的优点是加载速度比较快。

